CREATE TABLE clientes (
    id_cliente BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    nome VARCHAR(100) NOT NULL,
    cpf VARCHAR(11) UNIQUE NOT NULL,
    contato VARCHAR(20) NOT NULL,
    data_cadastro DATE NOT NULL DEFAULT CURRENT_DATE,
    ultima_atualizacao TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    ativo BOOLEAN DEFAULT TRUE
);

CREATE TABLE funcionarios (
    id_funcionario BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    nome VARCHAR(100) NOT NULL,
    funcao VARCHAR(50) NOT NULL,
    data_contratacao DATE,
    salario DECIMAL(10, 2),
    especialidade VARCHAR(100),
    ativo BOOLEAN DEFAULT TRUE,
    auth_user_id UUID
);

CREATE TABLE materiais (
    id_material BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    descricao VARCHAR(200) NOT NULL,
    valor_unitario DECIMAL(10, 2) NOT NULL,
    estoque_atual INT NOT NULL,
    estoque_minimo INT DEFAULT 10,
    data_ultima_compra DATE,
    fornecedor VARCHAR(100),
    codigo_barras VARCHAR(50)
);

CREATE TABLE historico_precos_materiais (
    id_historico BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    id_material BIGINT REFERENCES materiais(id_material),
    valor_anterior DECIMAL(10, 2) NOT NULL,
    valor_novo DECIMAL(10, 2) NOT NULL,
    data_alteracao TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    motivo_alteracao VARCHAR(200)
);

CREATE TABLE veiculos (
    id_veiculo BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    placa VARCHAR(7) UNIQUE NOT NULL,
    modelo VARCHAR(50) NOT NULL,
    marca VARCHAR(50),
    ano INT,
    cor VARCHAR(30),
    id_cliente BIGINT REFERENCES clientes(id_cliente),
    data_cadastro DATE NOT NULL DEFAULT CURRENT_DATE
);

CREATE TABLE tipos_servicos (
    id_tipo_servico BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    descricao VARCHAR(100) NOT NULL,
    valor_base DECIMAL(10, 2) NOT NULL,
    tempo_estimado_minutos INT,
    requer_agendamento BOOLEAN DEFAULT FALSE
);

CREATE TABLE historico_precos_servicos (
    id_historico BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    id_tipo_servico BIGINT REFERENCES tipos_servicos(id_tipo_servico),
    valor_anterior DECIMAL(10, 2) NOT NULL,
    valor_novo DECIMAL(10, 2) NOT NULL,
    data_alteracao TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    motivo_alteracao VARCHAR(200)
);

CREATE TABLE ordens_servico (
    id_ordem BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    id_veiculo BIGINT REFERENCES veiculos(id_veiculo),
    data_entrada DATE NOT NULL,
    data_entrega_prevista DATE,
    data_entrega_efetiva DATE,
    status VARCHAR(30) NOT NULL DEFAULT 'Aberta',
    valor_total DECIMAL(10, 2),
    observacoes TEXT,
    km_atual INT
);

CREATE TABLE itens_servico (
    id_item_servico BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    id_ordem BIGINT REFERENCES ordens_servico(id_ordem),
    id_tipo_servico BIGINT REFERENCES tipos_servicos(id_tipo_servico),
    id_funcionario BIGINT REFERENCES funcionarios(id_funcionario),
    valor_cobrado DECIMAL(10, 2) NOT NULL,
    data_inicio TIMESTAMP WITH TIME ZONE,
    data_fim TIMESTAMP WITH TIME ZONE,
    status VARCHAR(30) DEFAULT 'Pendente',
    observacoes TEXT
);

CREATE TABLE materiais_utilizados (
    id_material_utilizado BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    id_item_servico BIGINT REFERENCES itens_servico(id_item_servico),
    id_material BIGINT REFERENCES materiais(id_material),
    quantidade INT NOT NULL,
    valor_unitario DECIMAL(10, 2) NOT NULL,
    desconto_percentual DECIMAL(5, 2) DEFAULT 0
);

CREATE TABLE agendamentos (
    id_agendamento BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    id_cliente BIGINT REFERENCES clientes(id_cliente),
    id_veiculo BIGINT REFERENCES veiculos(id_veiculo),
    id_tipo_servico BIGINT REFERENCES tipos_servicos(id_tipo_servico),
    data_agendada DATE NOT NULL,
    hora_agendada TIME NOT NULL,
    status VARCHAR(30) DEFAULT 'Agendado',
    observacoes TEXT
);

CREATE TABLE pagamentos (
    id_pagamento BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    id_ordem BIGINT REFERENCES ordens_servico(id_ordem),
    valor DECIMAL(10, 2) NOT NULL,
    forma_pagamento VARCHAR(50) NOT NULL,
    data_pagamento TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    parcelas INT DEFAULT 1,
    status VARCHAR(30) DEFAULT 'Realizado'
);

CREATE TABLE avaliacoes (
    id_avaliacao BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    id_ordem BIGINT REFERENCES ordens_servico(id_ordem),
    nota INT NOT NULL CHECK (nota BETWEEN 1 AND 5),
    comentario TEXT,
    data_avaliacao TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE historico_manutencoes (
    id_historico BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    id_veiculo BIGINT REFERENCES veiculos(id_veiculo),
    data_manutencao DATE NOT NULL,
    km_registrado INT,
    descricao TEXT,
    valor_total DECIMAL(10, 2),
    local_manutencao VARCHAR(100) DEFAULT 'Oficina Própria'
);

CREATE TABLE log_validacao (
    id_log BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    tabela VARCHAR(50) NOT NULL,
    id_registro BIGINT NOT NULL,
    descricao TEXT NOT NULL,
    data_ocorrencia TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    corrigido BOOLEAN DEFAULT FALSE
);

CREATE TABLE movimentacoes_estoque (
    id_movimentacao BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    id_material BIGINT REFERENCES materiais(id_material),
    tipo_movimentacao CHAR(1) NOT NULL CHECK (tipo_movimentacao IN ('E', 'S')),
    quantidade INT NOT NULL,
    data_movimentacao TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    motivo VARCHAR(100) NOT NULL,
    documento_referencia VARCHAR(50),
    id_funcionario BIGINT REFERENCES funcionarios(id_funcionario),
    observacoes TEXT
);

CREATE INDEX idx_veiculos_placa ON veiculos(placa);
CREATE INDEX idx_clientes_cpf ON clientes(cpf);
CREATE INDEX idx_ordens_data_entrada ON ordens_servico(data_entrada);
CREATE INDEX idx_ordens_status ON ordens_servico(status);
CREATE INDEX idx_itens_servico_ordem ON itens_servico(id_ordem);
CREATE INDEX idx_materiais_utilizados_item ON materiais_utilizados(id_item_servico);
CREATE INDEX idx_funcionarios_auth_user_id ON funcionarios(auth_user_id);

ALTER TABLE clientes
ADD CONSTRAINT check_cpf_format
CHECK (cpf ~ '^[0-9]{11}$');

ALTER TABLE veiculos
ADD CONSTRAINT check_placa_format
CHECK (placa ~ '^[A-Z0-9]{7}$');

ALTER TABLE veiculos
ADD CONSTRAINT check_ano_veiculo
CHECK (ano BETWEEN 1900 AND EXTRACT(YEAR FROM CURRENT_DATE) + 1);

ALTER TABLE itens_servico
ADD CONSTRAINT check_valor_positivo
CHECK (valor_cobrado > 0);

ALTER TABLE ordens_servico
ADD CONSTRAINT check_datas_ordem
CHECK (
    (data_entrega_prevista IS NULL OR data_entrega_prevista >= data_entrada) AND
    (data_entrega_efetiva IS NULL OR data_entrega_efetiva >= data_entrada)
);

ALTER TABLE materiais
ADD CONSTRAINT check_estoque_positivo
CHECK (estoque_atual >= 0);

ALTER TABLE avaliacoes
ADD CONSTRAINT check_nota_range
CHECK (nota BETWEEN 1 AND 5);

ALTER TABLE ordens_servico
ADD CONSTRAINT check_km_positivo
CHECK (km_atual >= 0);

CREATE OR REPLACE FUNCTION validar_cpf(cpf TEXT)
RETURNS BOOLEAN AS $$
DECLARE
    v_cpf TEXT;
BEGIN
    v_cpf := REGEXP_REPLACE(cpf, '[^0-9]', '', 'g');
    
    IF LENGTH(v_cpf) != 11 THEN
        RETURN FALSE;
    END IF;
    
    IF v_cpf = '00000000000' OR v_cpf = '11111111111' OR v_cpf = '22222222222' OR
       v_cpf = '33333333333' OR v_cpf = '44444444444' OR v_cpf = '55555555555' OR
       v_cpf = '66666666666' OR v_cpf = '77777777777' OR v_cpf = '88888888888' OR
       v_cpf = '99999999999' THEN
        RETURN FALSE;
    END IF;
    
    RETURN TRUE;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION trigger_validar_cpf()
RETURNS TRIGGER AS $$
BEGIN
    IF NOT validar_cpf(NEW.cpf) THEN
        RAISE EXCEPTION 'CPF inválido';
    END IF;
    
    NEW.cpf := REGEXP_REPLACE(NEW.cpf, '[^0-9]', '', 'g');
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE TRIGGER trigger_validar_cpf
BEFORE INSERT OR UPDATE OF cpf ON clientes
FOR EACH ROW EXECUTE FUNCTION trigger_validar_cpf();

CREATE OR REPLACE FUNCTION validar_placa_veiculo()
RETURNS TRIGGER AS $$
DECLARE
    v_placa VARCHAR(7);
BEGIN
    v_placa := UPPER(REGEXP_REPLACE(NEW.placa, '[^A-Za-z0-9]', '', 'g'));
    
    IF LENGTH(v_placa) != 7 THEN
        RAISE EXCEPTION 'Placa inválida: deve ter 7 caracteres';
    END IF;
    
    IF v_placa ~ '^[A-Z]{3}[0-9]{4}$' THEN
        NULL;
    ELSIF v_placa ~ '^[A-Z]{3}[0-9][A-Z][0-9]{2}$' THEN
        NULL;
    ELSE
        RAISE EXCEPTION 'Placa inválida: formato não reconhecido';
    END IF;
    
    NEW.placa := v_placa;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE TRIGGER trigger_validar_placa
BEFORE INSERT OR UPDATE OF placa ON veiculos
FOR EACH ROW EXECUTE FUNCTION validar_placa_veiculo();

CREATE OR REPLACE FUNCTION validar_datas_ordem()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.data_entrada > CURRENT_DATE THEN
        RAISE EXCEPTION 'Data de entrada inválida: não pode ser futura';
    END IF;
    
    IF NEW.data_entrega_prevista IS NOT NULL AND NEW.data_entrega_prevista < NEW.data_entrada THEN
        RAISE EXCEPTION 'Data de entrega prevista inválida: deve ser posterior à data de entrada';
    END IF;
    
    IF NEW.data_entrega_efetiva IS NOT NULL THEN
        IF NEW.data_entrega_efetiva < NEW.data_entrada THEN
            RAISE EXCEPTION 'Data de entrega efetiva inválida: deve ser posterior à data de entrada';
        END IF;
        
        IF NEW.status != 'Finalizada' AND NEW.status != 'Cancelada' THEN
            NEW.status := 'Finalizada';
        END IF;
    END IF;
    
    IF NEW.status = 'Finalizada' AND NEW.data_entrega_efetiva IS NULL THEN
        NEW.data_entrega_efetiva := CURRENT_DATE;
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE TRIGGER trigger_validar_datas_ordem
BEFORE INSERT OR UPDATE ON ordens_servico
FOR EACH ROW EXECUTE FUNCTION validar_datas_ordem();

CREATE OR REPLACE FUNCTION atualizar_estoque()
RETURNS TRIGGER AS $$
DECLARE
    v_estoque_atual INTEGER;
BEGIN
    SELECT estoque_atual INTO v_estoque_atual
    FROM materiais
    WHERE id_material = NEW.id_material;
    
    IF v_estoque_atual < NEW.quantidade THEN
        RAISE EXCEPTION 'Estoque insuficiente para o material (ID: %). Disponível: %, Solicitado: %', 
                        NEW.id_material, v_estoque_atual, NEW.quantidade;
    END IF;
    
    UPDATE materiais
    SET estoque_atual = estoque_atual - NEW.quantidade
    WHERE id_material = NEW.id_material;
    
    INSERT INTO movimentacoes_estoque (
        id_material, 
        tipo_movimentacao, 
        quantidade, 
        motivo, 
        documento_referencia
    ) VALUES (
        NEW.id_material,
        'S',
        NEW.quantidade,
        'Utilização em serviço',
        'OS-' || (SELECT id_ordem FROM itens_servico WHERE id_item_servico = NEW.id_item_servico)
    );
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE TRIGGER trigger_atualizar_estoque
AFTER INSERT ON materiais_utilizados
FOR EACH ROW EXECUTE FUNCTION atualizar_estoque();

CREATE OR REPLACE FUNCTION reverter_estoque()
RETURNS TRIGGER AS $$
BEGIN
    UPDATE materiais
    SET estoque_atual = estoque_atual + OLD.quantidade
    WHERE id_material = OLD.id_material;
    
    INSERT INTO movimentacoes_estoque (
        id_material, 
        tipo_movimentacao, 
        quantidade, 
        motivo, 
        documento_referencia
    ) VALUES (
        OLD.id_material,
        'E',
        OLD.quantidade,
        'Estorno de utilização em serviço',
        'OS-' || (SELECT id_ordem FROM itens_servico WHERE id_item_servico = OLD.id_item_servico)
    );
    
    RETURN OLD;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE TRIGGER trigger_reverter_estoque
AFTER DELETE ON materiais_utilizados
FOR EACH ROW EXECUTE FUNCTION reverter_estoque();

CREATE OR REPLACE FUNCTION registrar_alteracao_preco_servico()
RETURNS TRIGGER AS $$
BEGIN
    IF OLD.valor_base != NEW.valor_base THEN
        INSERT INTO historico_precos_servicos (
            id_tipo_servico,
            valor_anterior,
            valor_novo,
            data_alteracao,
            motivo_alteracao
        ) VALUES (
            NEW.id_tipo_servico,
            OLD.valor_base,
            NEW.valor_base,
            CURRENT_TIMESTAMP,
            'Atualização de preço'
        );
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE TRIGGER trigger_registrar_alteracao_preco_servico
AFTER UPDATE OF valor_base ON tipos_servicos
FOR EACH ROW EXECUTE FUNCTION registrar_alteracao_preco_servico();

CREATE OR REPLACE FUNCTION registrar_alteracao_preco_material()
RETURNS TRIGGER AS $$
BEGIN
    IF OLD.valor_unitario != NEW.valor_unitario THEN
        INSERT INTO historico_precos_materiais (
            id_material,
            valor_anterior,
            valor_novo,
            data_alteracao,
            motivo_alteracao
        ) VALUES (
            NEW.id_material,
            OLD.valor_unitario,
            NEW.valor_unitario,
            CURRENT_TIMESTAMP,
            'Atualização de preço'
        );
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE TRIGGER trigger_registrar_alteracao_preco_material
AFTER UPDATE OF valor_unitario ON materiais
FOR EACH ROW EXECUTE FUNCTION registrar_alteracao_preco_material();

CREATE OR REPLACE FUNCTION validar_quilometragem()
RETURNS TRIGGER AS $$
DECLARE
    v_ultima_km INTEGER;
BEGIN
    SELECT MAX(km_atual) INTO v_ultima_km
    FROM ordens_servico
    WHERE id_veiculo = NEW.id_veiculo
      AND id_ordem != NEW.id_ordem
      AND km_atual IS NOT NULL;
    
    IF v_ultima_km IS NOT NULL AND NEW.km_atual < v_ultima_km THEN
        INSERT INTO log_validacao (
            tabela,
            id_registro,
            descricao,
            data_ocorrencia
        ) VALUES (
            'ordens_servico',
            NEW.id_ordem,
            format('Quilometragem suspeita: valor atual (%s) é menor que o último registrado (%s) para o veículo (ID: %s)',
                   NEW.km_atual, v_ultima_km, NEW.id_veiculo),
            CURRENT_TIMESTAMP
        );
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE TRIGGER trigger_validar_quilometragem
BEFORE INSERT OR UPDATE OF km_atual ON ordens_servico
FOR EACH ROW WHEN (NEW.km_atual IS NOT NULL)
EXECUTE FUNCTION validar_quilometragem();

CREATE OR REPLACE FUNCTION calcular_valor_total_ordem(p_id_ordem BIGINT)
RETURNS DECIMAL(10,2) AS $$
DECLARE
    v_total_servicos DECIMAL(10,2);
    v_total_materiais DECIMAL(10,2);
    v_valor_total DECIMAL(10,2);
BEGIN
    SELECT COALESCE(SUM(valor_cobrado), 0) INTO v_total_servicos
    FROM itens_servico
    WHERE id_ordem = p_id_ordem;
    
    SELECT COALESCE(SUM(mu.quantidade * mu.valor_unitario * (1 - mu.desconto_percentual/100)), 0) INTO v_total_materiais
    FROM materiais_utilizados mu
    JOIN itens_servico is_tab ON mu.id_item_servico = is_tab.id_item_servico
    WHERE is_tab.id_ordem = p_id_ordem;
    
    v_valor_total := v_total_servicos + v_total_materiais;
    
    RETURN v_valor_total;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION atualizar_valor_total_ordem()
RETURNS TRIGGER AS $$
DECLARE
    v_valor_total DECIMAL(10,2);
BEGIN
    v_valor_total := calcular_valor_total_ordem(NEW.id_ordem);
    
    UPDATE ordens_servico
    SET valor_total = v_valor_total
    WHERE id_ordem = NEW.id_ordem;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE TRIGGER trigger_atualizar_valor_total_item_servico
AFTER INSERT OR UPDATE ON itens_servico
FOR EACH ROW EXECUTE FUNCTION atualizar_valor_total_ordem();

CREATE OR REPLACE FUNCTION atualizar_valor_total_material()
RETURNS TRIGGER AS $$
DECLARE
    v_id_ordem BIGINT;
    v_valor_total DECIMAL(10,2);
BEGIN
    SELECT id_ordem INTO v_id_ordem
    FROM itens_servico
    WHERE id_item_servico = NEW.id_item_servico;
    
    v_valor_total := calcular_valor_total_ordem(v_id_ordem);
    
    UPDATE ordens_servico
    SET valor_total = v_valor_total
    WHERE id_ordem = v_id_ordem;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE TRIGGER trigger_atualizar_valor_total_material
AFTER INSERT OR UPDATE ON materiais_utilizados
FOR EACH ROW EXECUTE FUNCTION atualizar_valor_total_material();

CREATE VIEW vw_servicos_por_cliente AS
SELECT 
    c.nome AS cliente,
    v.placa,
    v.modelo,
    ts.descricao AS servico,
    os.data_entrada,
    os.data_entrega_efetiva,
    item.valor_cobrado,
    f.nome AS responsavel
FROM clientes c
JOIN veiculos v ON c.id_cliente = v.id_cliente
JOIN ordens_servico os ON v.id_veiculo = os.id_veiculo
JOIN itens_servico item ON os.id_ordem = item.id_ordem
JOIN tipos_servicos ts ON item.id_tipo_servico = ts.id_tipo_servico
JOIN funcionarios f ON item.id_funcionario = f.id_funcionario;

CREATE VIEW vw_faturamento_mensal AS
SELECT 
    EXTRACT(YEAR FROM os.data_entrega_efetiva) AS ano,
    EXTRACT(MONTH FROM os.data_entrega_efetiva) AS mes,
    SUM(item.valor_cobrado) AS faturamento_servicos,
    SUM(mu.quantidade * mu.valor_unitario) AS faturamento_pecas,
    SUM(item.valor_cobrado) + SUM(mu.quantidade * mu.valor_unitario) AS faturamento_total,
    COUNT(DISTINCT os.id_ordem) AS quantidade_servicos
FROM ordens_servico os
JOIN itens_servico item ON os.id_ordem = item.id_ordem
LEFT JOIN materiais_utilizados mu ON item.id_item_servico = mu.id_item_servico
WHERE os.status = 'Finalizada'
GROUP BY ano, mes
ORDER BY ano, mes;

CREATE VIEW vw_desempenho_funcionarios AS
SELECT 
    f.nome AS funcionario,
    f.funcao,
    COUNT(item.id_item_servico) AS servicos_realizados,
    SUM(item.valor_cobrado) AS valor_total_servicos,
    AVG(EXTRACT(EPOCH FROM (item.data_fim - item.data_inicio))/60) AS tempo_medio_minutos
FROM funcionarios f
JOIN itens_servico item ON f.id_funcionario = item.id_funcionario
WHERE item.status = 'Concluído'
GROUP BY f.id_funcionario, f.nome, f.funcao;

CREATE VIEW vw_estoque_critico AS
SELECT 
    descricao,
    estoque_atual,
    estoque_minimo,
    valor_unitario,
    estoque_atual * valor_unitario AS valor_em_estoque
FROM materiais
WHERE estoque_atual <= estoque_minimo
ORDER BY (estoque_atual::float / estoque_minimo) ASC;

CREATE VIEW vw_historico_manutencao_veiculo AS
SELECT 
    v.placa,
    v.modelo,
    c.nome AS proprietario,
    os.data_entrada,
    ts.descricao AS servico,
    item.valor_cobrado,
    os.km_atual,
    os.observacoes
FROM veiculos v
JOIN clientes c ON v.id_cliente = c.id_cliente
JOIN ordens_servico os ON v.id_veiculo = os.id_veiculo
JOIN itens_servico item ON os.id_ordem = item.id_ordem
JOIN tipos_servicos ts ON item.id_tipo_servico = ts.id_tipo_servico
ORDER BY v.placa, os.data_entrada DESC;
